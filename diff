diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
index 029e6ad..f5f1422 100644
--- a/.github/workflows/ci.yml
+++ b/.github/workflows/ci.yml
@@ -94,12 +94,20 @@ jobs:
       - name: Set up Docker Buildx
         uses: docker/setup-buildx-action@v3
 
-      - name: Build Docker image
+      - name: Login to GitHub Container Registry
+        uses: docker/login-action@v3
+        with:
+          registry: ghcr.io
+          username: ${{ github.actor }}
+          password: ${{ secrets.GITHUB_TOKEN }}
+
+      - name: Build and push Docker image
         uses: docker/build-push-action@v6
         with:
           platforms: linux/amd64,linux/arm64
           context: ./crates/kftray-server
           file: ./crates/kftray-server/Dockerfile
-          push: false
+          push: true
           tags: |
             ghcr.io/${{ github.repository_owner }}/kftray-server:${{ github.sha }}
+            ghcr.io/${{ github.repository_owner }}/kftray-server:${{ github.head_ref}}
diff --git a/Cargo.lock b/Cargo.lock
index 1da4e15..078f218 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -541,7 +541,7 @@ dependencies = [
  "cairo-sys-rs",
  "glib",
  "libc",
- "thiserror 1.0.69",
+ "thiserror",
 ]
 
 [[package]]
@@ -1413,7 +1413,7 @@ source = "git+https://github.com/tauri-apps/fix-path-env-rs#0e479e2804edc1a7e5f1
 dependencies = [
  "home",
  "strip-ansi-escapes",
- "thiserror 1.0.69",
+ "thiserror",
 ]
 
 [[package]]
@@ -1814,7 +1814,7 @@ dependencies = [
  "glib",
  "libc",
  "once_cell",
- "thiserror 1.0.69",
+ "thiserror",
 ]
 
 [[package]]
@@ -1862,7 +1862,7 @@ dependencies = [
  "libc",
  "once_cell",
  "smallvec",
- "thiserror 1.0.69",
+ "thiserror",
 ]
 
 [[package]]
@@ -2758,7 +2758,7 @@ dependencies = [
  "combine",
  "jni-sys",
  "log",
- "thiserror 1.0.69",
+ "thiserror",
  "walkdir",
 ]
 
@@ -2801,7 +2801,7 @@ dependencies = [
  "jsonptr",
  "serde",
  "serde_json",
- "thiserror 1.0.69",
+ "thiserror",
 ]
 
 [[package]]
@@ -2816,7 +2816,7 @@ dependencies = [
  "pest_derive",
  "regex",
  "serde_json",
- "thiserror 1.0.69",
+ "thiserror",
 ]
 
 [[package]]
@@ -2925,15 +2925,12 @@ dependencies = [
 name = "kftray-server"
 version = "0.15.1"
 dependencies = [
- "async-trait",
- "byteorder",
  "env_logger",
- "futures",
  "log",
  "mockall",
- "thiserror 2.0.3",
  "tokio",
  "tokio-test",
+ "url",
 ]
 
 [[package]]
@@ -3066,7 +3063,7 @@ dependencies = [
  "serde",
  "serde_json",
  "serde_yaml",
- "thiserror 1.0.69",
+ "thiserror",
  "tokio",
  "tokio-tungstenite",
  "tokio-util",
@@ -3089,7 +3086,7 @@ dependencies = [
  "serde",
  "serde-value",
  "serde_json",
- "thiserror 1.0.69",
+ "thiserror",
 ]
 
 [[package]]
@@ -3114,7 +3111,7 @@ dependencies = [
  "pin-project",
  "serde",
  "serde_json",
- "thiserror 1.0.69",
+ "thiserror",
  "tokio",
  "tokio-util",
  "tracing",
@@ -3471,9 +3468,9 @@ dependencies = [
 
 [[package]]
 name = "mockall"
-version = "0.13.0"
+version = "0.13.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d4c28b3fb6d753d28c20e826cd46ee611fda1cf3cde03a443a974043247c065a"
+checksum = "39a6bfcc6c8c7eed5ee98b9c3e33adc726054389233e201c95dab2d41a3839d2"
 dependencies = [
  "cfg-if",
  "downcast",
@@ -3485,9 +3482,9 @@ dependencies = [
 
 [[package]]
 name = "mockall_derive"
-version = "0.13.0"
+version = "0.13.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "341014e7f530314e9a1fdbc7400b244efea7122662c96bfa248c31da5bfb2020"
+checksum = "25ca3004c2efe9011bd4e461bd8256445052b9615405b4f7ea43fc8ca5c20898"
 dependencies = [
  "cfg-if",
  "proc-macro2",
@@ -3522,7 +3519,7 @@ dependencies = [
  "jni-sys",
  "ndk-sys",
  "num_enum",
- "thiserror 1.0.69",
+ "thiserror",
 ]
 
 [[package]]
@@ -3550,7 +3547,7 @@ dependencies = [
  "libc",
  "num-derive",
  "num-traits",
- "thiserror 1.0.69",
+ "thiserror",
 ]
 
 [[package]]
@@ -4107,7 +4104,7 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "879952a81a83930934cbf1786752d6dedc3b1f29e8f8fb2ad1d0a36f377cf442"
 dependencies = [
  "memchr",
- "thiserror 1.0.69",
+ "thiserror",
  "ucd-trie",
 ]
 
@@ -4706,7 +4703,7 @@ checksum = "ba009ff324d1fc1b900bd1fdb31564febe58a8ccc8a6fdbb93b543d33b13ca43"
 dependencies = [
  "getrandom 0.2.15",
  "libredox",
- "thiserror 1.0.69",
+ "thiserror",
 ]
 
 [[package]]
@@ -5497,7 +5494,7 @@ dependencies = [
  "sha2",
  "smallvec",
  "sqlformat",
- "thiserror 1.0.69",
+ "thiserror",
  "tokio",
  "tokio-stream",
  "tracing",
@@ -5580,7 +5577,7 @@ dependencies = [
  "smallvec",
  "sqlx-core",
  "stringprep",
- "thiserror 1.0.69",
+ "thiserror",
  "tracing",
  "whoami",
 ]
@@ -5618,7 +5615,7 @@ dependencies = [
  "smallvec",
  "sqlx-core",
  "stringprep",
- "thiserror 1.0.69",
+ "thiserror",
  "tracing",
  "whoami",
 ]
@@ -6019,7 +6016,7 @@ dependencies = [
  "tauri-runtime-wry",
  "tauri-utils",
  "tempfile",
- "thiserror 1.0.69",
+ "thiserror",
  "time",
  "tokio",
  "url",
@@ -6069,7 +6066,7 @@ dependencies = [
  "serde_json",
  "sha2",
  "tauri-utils",
- "thiserror 1.0.69",
+ "thiserror",
  "time",
  "uuid",
  "walkdir",
@@ -6100,7 +6097,7 @@ dependencies = [
  "serde_json",
  "serde_repr",
  "tauri",
- "thiserror 1.0.69",
+ "thiserror",
 ]
 
 [[package]]
@@ -6117,7 +6114,7 @@ dependencies = [
  "serde",
  "serde_json",
  "tauri-utils",
- "thiserror 1.0.69",
+ "thiserror",
  "url",
  "uuid",
  "webview2-com",
@@ -6169,7 +6166,7 @@ dependencies = [
  "serde",
  "serde_json",
  "serde_with",
- "thiserror 1.0.69",
+ "thiserror",
  "url",
  "walkdir",
  "windows-version",
@@ -6238,16 +6235,7 @@ version = "1.0.69"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "b6aaf5339b578ea85b50e080feb250a3e8ae8cfcdff9a461c9ec2904bc923f52"
 dependencies = [
- "thiserror-impl 1.0.69",
-]
-
-[[package]]
-name = "thiserror"
-version = "2.0.3"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c006c85c7651b3cf2ada4584faa36773bd07bac24acfb39f3c431b36d7e667aa"
-dependencies = [
- "thiserror-impl 2.0.3",
+ "thiserror-impl",
 ]
 
 [[package]]
@@ -6261,17 +6249,6 @@ dependencies = [
  "syn 2.0.87",
 ]
 
-[[package]]
-name = "thiserror-impl"
-version = "2.0.3"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f077553d607adc1caf65430528a576c757a71ed73944b66ebb58ef2bbd243568"
-dependencies = [
- "proc-macro2",
- "quote",
- "syn 2.0.87",
-]
-
 [[package]]
 name = "thread_local"
 version = "1.1.8"
@@ -6673,7 +6650,7 @@ dependencies = [
  "log",
  "rand 0.8.5",
  "sha1",
- "thiserror 1.0.69",
+ "thiserror",
  "utf-8",
 ]
 
@@ -7162,7 +7139,7 @@ dependencies = [
  "regex",
  "serde",
  "serde_json",
- "thiserror 1.0.69",
+ "thiserror",
  "windows 0.39.0",
  "windows-bindgen",
  "windows-metadata",
@@ -7744,7 +7721,7 @@ dependencies = [
  "nix 0.28.0",
  "os_pipe",
  "tempfile",
- "thiserror 1.0.69",
+ "thiserror",
  "tree_magic_mini",
  "wayland-backend",
  "wayland-client",
@@ -7793,7 +7770,7 @@ dependencies = [
  "sha2",
  "soup2",
  "tao",
- "thiserror 1.0.69",
+ "thiserror",
  "url",
  "webkit2gtk",
  "webkit2gtk-sys",
diff --git a/Cargo.toml b/Cargo.toml
index 61b02bf..e910826 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -1,9 +1,9 @@
 [workspace]
 members = [
-    "crates/kftray-server",
     "crates/kftray-tauri",
 	"crates/kftui",
 	"crates/kftray-portforward",
+	"crates/kftray-server",
 ]
 
 resolver = "2"
diff --git a/crates/kftray-server/Cargo.toml b/crates/kftray-server/Cargo.toml
index af3d9a7..08bdf75 100644
--- a/crates/kftray-server/Cargo.toml
+++ b/crates/kftray-server/Cargo.toml
@@ -14,10 +14,7 @@ edition = "2021"
 tokio = { version = "1", features = ["full"] }
 log = "0.4"
 env_logger = "0.11.5"
-byteorder = "1.4"
-thiserror = "2.0.2"
-async-trait = "0.1"
-futures = "0.3"
+url = "2.5.0"
 
 [dev-dependencies]
 mockall = "0.13"
diff --git a/crates/kftray-server/Dockerfile b/crates/kftray-server/Dockerfile
index 933c984..0063361 100644
--- a/crates/kftray-server/Dockerfile
+++ b/crates/kftray-server/Dockerfile
@@ -1,4 +1,4 @@
-FROM rust:1.82.0-alpine3.19 AS builder
+FROM rust:1.82.0-alpine3.20 AS builder
 
 RUN apk add --no-cache musl-dev
 
@@ -23,4 +23,3 @@ ENV PROXY_TYPE=tcp
 EXPOSE 8080
 
 CMD ["/kftray-server"]
-
diff --git a/crates/kftray-server/src/main.rs b/crates/kftray-server/src/main.rs
index c82e90e..4376de4 100644
--- a/crates/kftray-server/src/main.rs
+++ b/crates/kftray-server/src/main.rs
@@ -1,48 +1,64 @@
 mod proxy;
 
-use std::{
-    env,
-    sync::Arc,
+use std::env;
+use std::net::ToSocketAddrs;
+use std::sync::Arc;
+
+use log::{
+    error,
+    info,
 };
+use tokio::signal;
+use url::Url;
 
-use proxy::{
+use crate::proxy::{
     config::{
         ProxyConfig,
         ProxyType,
     },
     error::ProxyError,
-    http,
-    tcp,
-    udp,
+    server::ProxyServer,
 };
-use tokio::sync::Notify;
 
-#[tokio::main]
-async fn main() -> Result<(), ProxyError> {
-    env_logger::init();
+/// Loads proxy configuration from environment variables
+///
+/// # Returns
+/// * `Result<ProxyConfig, ProxyError>` - Parsed configuration or error details
+///
+/// # Environment Variables
+/// * `REMOTE_ADDRESS` - Target server hostname/IP
+/// * `REMOTE_PORT` - Target server port
+/// * `LOCAL_PORT` - Local proxy listening port
+/// * `PROXY_TYPE` - Protocol type ("tcp" or "udp")
+fn load_config() -> Result<ProxyConfig, ProxyError> {
+    let target_host = env::var("REMOTE_ADDRESS")
+        .map_err(|_| ProxyError::Configuration("REMOTE_ADDRESS not set".into()))?;
 
-    let config = load_config()?;
-    let shutdown = Arc::new(Notify::new());
+    let resolved_host = if target_host.contains("://") {
+        let url = Url::parse(&target_host)
+            .map_err(|e| ProxyError::Configuration(format!("Invalid URL: {}", e)))?;
 
-    match config.proxy_type {
-        ProxyType::Http => {
-            http::start_proxy(config, shutdown.clone()).await?;
-        }
-        ProxyType::Tcp => {
-            tcp::start_proxy(config, shutdown.clone()).await?;
+        url.host_str()
+            .ok_or_else(|| ProxyError::Configuration("No host found in URL".into()))?
+            .to_string()
+    } else {
+        let test_url = format!("http://{}", target_host);
+        if let Ok(url) = Url::parse(&test_url) {
+            if let Some(host) = url.host_str() {
+                host.to_string()
+            } else {
+                target_host
+            }
+        } else {
+            target_host
         }
-        ProxyType::Udp => {
-            udp::start_proxy(config, shutdown.clone()).await?;
-        }
-    }
-
-    shutdown.notified().await;
-    Ok(())
-}
+    };
 
-fn load_config() -> Result<ProxyConfig, ProxyError> {
-    let target_host = env::var("REMOTE_ADDRESS")
-        .map_err(|_| ProxyError::Configuration("REMOTE_ADDRESS not set".into()))?;
+    let socket_addr = format!("{}:0", resolved_host)
+        .to_socket_addrs()
+        .map_err(|e| ProxyError::Configuration(format!("Failed to resolve hostname: {}", e)))?
+        .next()
+        .ok_or_else(|| ProxyError::Configuration("No IP addresses found for hostname".into()))?;
 
     let target_port = env::var("REMOTE_PORT")
         .map_err(|_| ProxyError::Configuration("REMOTE_PORT not set".into()))?
@@ -56,10 +72,10 @@ fn load_config() -> Result<ProxyConfig, ProxyError> {
 
     let proxy_type = match env::var("PROXY_TYPE")
         .map_err(|_| ProxyError::Configuration("PROXY_TYPE not set".into()))?
+        .to_lowercase()
         .as_str()
     {
         "tcp" => ProxyType::Tcp,
-        "http" => ProxyType::Http,
         "udp" => ProxyType::Udp,
         t => {
             return Err(ProxyError::Configuration(format!(
@@ -69,10 +85,46 @@ fn load_config() -> Result<ProxyConfig, ProxyError> {
         }
     };
 
-    Ok(ProxyConfig::new(
-        target_host,
-        target_port,
-        proxy_port,
-        proxy_type,
-    ))
+    Ok(ProxyConfig::builder()
+        .target_host(socket_addr.ip().to_string())
+        .target_port(target_port)
+        .proxy_port(proxy_port)
+        .proxy_type(proxy_type)
+        .build()?)
+}
+
+/// Main entry point for the proxy server application
+///
+/// Sets up logging, loads configuration, starts the proxy server,
+/// and handles shutdown signals (Ctrl+C and SIGTERM)
+#[tokio::main]
+async fn main() -> Result<(), ProxyError> {
+    env_logger::init();
+
+    let config = load_config()?;
+    let server = Arc::new(ProxyServer::new(config));
+    let server_clone = Arc::clone(&server);
+
+    let server_handle = tokio::spawn(async move { server_clone.run().await });
+
+    tokio::select! {
+        _ = signal::ctrl_c() => {
+            info!("Received Ctrl+C signal");
+        }
+        _ = async {
+            if let Ok(mut sigterm) = signal::unix::signal(signal::unix::SignalKind::terminate()) {
+                let _ = sigterm.recv().await;
+                info!("Received SIGTERM signal");
+            }
+        } => {}
+    }
+
+    server.shutdown();
+
+    if let Err(e) = tokio::time::timeout(tokio::time::Duration::from_secs(5), server_handle).await {
+        error!("Server shutdown timed out: {}", e);
+    }
+
+    info!("Server shutdown complete");
+    Ok(())
 }
diff --git a/crates/kftray-server/src/proxy/config.rs b/crates/kftray-server/src/proxy/config.rs
index d9ec998..38099d8 100644
--- a/crates/kftray-server/src/proxy/config.rs
+++ b/crates/kftray-server/src/proxy/config.rs
@@ -1,27 +1,84 @@
+/// Configuration settings for a proxy instance
 #[derive(Debug, Clone)]
 pub struct ProxyConfig {
+    /// Host address of the target server to proxy to
     pub target_host: String,
+    /// Port number of the target server
     pub target_port: u16,
+    /// Local port number the proxy listens on
     pub proxy_port: u16,
+    /// Type of proxy protocol (TCP or UDP)
     pub proxy_type: ProxyType,
 }
 
-#[derive(Debug, Clone)]
-pub enum ProxyType {
-    Http,
-    Tcp,
-    Udp,
+/// Builder pattern implementation for creating ProxyConfig instances
+#[derive(Default)]
+pub struct ProxyConfigBuilder {
+    target_host: Option<String>,
+    target_port: Option<u16>,
+    proxy_port: Option<u16>,
+    proxy_type: Option<ProxyType>,
 }
 
-impl ProxyConfig {
-    pub fn new(
-        target_host: String, target_port: u16, proxy_port: u16, proxy_type: ProxyType,
-    ) -> Self {
-        Self {
+impl ProxyConfigBuilder {
+    pub fn new() -> Self {
+        Self::default()
+    }
+
+    pub fn target_host(mut self, host: String) -> Self {
+        self.target_host = Some(host);
+        self
+    }
+
+    pub fn target_port(mut self, port: u16) -> Self {
+        self.target_port = Some(port);
+        self
+    }
+
+    pub fn proxy_port(mut self, port: u16) -> Self {
+        self.proxy_port = Some(port);
+        self
+    }
+
+    pub fn proxy_type(mut self, proxy_type: ProxyType) -> Self {
+        self.proxy_type = Some(proxy_type);
+        self
+    }
+
+    pub fn build(self) -> Result<ProxyConfig, String> {
+        let target_host = self
+            .target_host
+            .ok_or_else(|| "target_host is required".to_string())?;
+        let target_port = self
+            .target_port
+            .ok_or_else(|| "target_port is required".to_string())?;
+        let proxy_port = self
+            .proxy_port
+            .ok_or_else(|| "proxy_port is required".to_string())?;
+        let proxy_type = self
+            .proxy_type
+            .ok_or_else(|| "proxy_type is required".to_string())?;
+
+        Ok(ProxyConfig {
             target_host,
             target_port,
             proxy_port,
             proxy_type,
-        }
+        })
+    }
+}
+
+impl ProxyConfig {
+    pub fn builder() -> ProxyConfigBuilder {
+        ProxyConfigBuilder::new()
     }
 }
+
+/// Supported proxy protocol types
+#[derive(Debug, Clone)]
+pub enum ProxyType {
+    /// TCP proxy mode
+    Tcp,
+    /// UDP proxy mode
+    Udp,
+}
diff --git a/crates/kftray-server/src/proxy/error.rs b/crates/kftray-server/src/proxy/error.rs
index 59315d2..b5e0c99 100644
--- a/crates/kftray-server/src/proxy/error.rs
+++ b/crates/kftray-server/src/proxy/error.rs
@@ -1,11 +1,21 @@
-use std::fmt;
-use std::io;
+use std::{
+    error::Error,
+    fmt,
+    io,
+    net::AddrParseError,
+};
 
+/// Represents the various error types that can occur during proxy operations.
 #[derive(Debug)]
 pub enum ProxyError {
+    /// Wraps standard IO errors from networking operations
     Io(io::Error),
+    /// Indicates invalid configuration settings or parameters
     Configuration(String),
+    /// Represents failures in establishing or maintaining connections
     Connection(String),
+    /// Indicates invalid or malformed data received during proxy operations
+    InvalidData(String),
 }
 
 impl fmt::Display for ProxyError {
@@ -14,6 +24,16 @@ impl fmt::Display for ProxyError {
             ProxyError::Io(err) => write!(f, "IO Error: {}", err),
             ProxyError::Configuration(msg) => write!(f, "Configuration Error: {}", msg),
             ProxyError::Connection(msg) => write!(f, "Connection Error: {}", msg),
+            ProxyError::InvalidData(msg) => write!(f, "Invalid Data Error: {}", msg),
+        }
+    }
+}
+
+impl Error for ProxyError {
+    fn source(&self) -> Option<&(dyn Error + 'static)> {
+        match self {
+            ProxyError::Io(err) => Some(err),
+            _ => None,
         }
     }
 }
@@ -23,3 +43,15 @@ impl From<io::Error> for ProxyError {
         ProxyError::Io(err)
     }
 }
+
+impl From<String> for ProxyError {
+    fn from(msg: String) -> Self {
+        ProxyError::Configuration(msg)
+    }
+}
+
+impl From<AddrParseError> for ProxyError {
+    fn from(err: AddrParseError) -> Self {
+        ProxyError::Configuration(format!("Invalid address format: {}", err))
+    }
+}
diff --git a/crates/kftray-server/src/proxy/http.rs b/crates/kftray-server/src/proxy/http.rs
deleted file mode 100644
index ce674c2..0000000
--- a/crates/kftray-server/src/proxy/http.rs
+++ /dev/null
@@ -1,174 +0,0 @@
-use std::time::Duration;
-
-use log::{
-    error,
-    info,
-};
-use tokio::{
-    io::{
-        AsyncReadExt,
-        AsyncWriteExt,
-    },
-    net::{
-        TcpListener,
-        TcpStream,
-    },
-    sync::Notify,
-    time,
-};
-
-use crate::proxy::{
-    config::ProxyConfig,
-    error::ProxyError,
-};
-
-const BUFFER_SIZE: usize = 65536;
-const MAX_RETRIES: u32 = 5;
-const INITIAL_RETRY_DELAY: Duration = Duration::from_millis(100);
-
-pub async fn start_proxy(
-    config: ProxyConfig, shutdown: std::sync::Arc<Notify>,
-) -> Result<(), ProxyError> {
-    let listener = TcpListener::bind(format!("0.0.0.0:{}", config.proxy_port)).await?;
-    info!("HTTP Proxy started on port {}", config.proxy_port);
-
-    loop {
-        tokio::select! {
-            accept_result = listener.accept() => {
-                match accept_result {
-                    Ok((client_stream, addr)) => {
-                        info!("Accepted connection from {}", addr);
-                        let config = config.clone();
-                        let shutdown = shutdown.clone();
-
-                        tokio::spawn(async move {
-                            if let Err(e) = handle_client(client_stream, config, shutdown).await {
-                                error!("Error handling client: {}", e);
-                            }
-                        });
-                    }
-                    Err(e) => error!("Failed to accept connection: {}", e),
-                }
-            }
-            _ = shutdown.notified() => {
-                info!("Shutdown signal received, stopping HTTP proxy");
-                break;
-            }
-        }
-    }
-
-    Ok(())
-}
-
-async fn handle_client(
-    client_stream: TcpStream, config: ProxyConfig, shutdown: std::sync::Arc<Notify>,
-) -> Result<(), ProxyError> {
-    let server_stream =
-        TcpStream::connect(format!("{}:{}", config.target_host, config.target_port))
-            .await
-            .map_err(|e| ProxyError::Connection(format!("Failed to connect to target: {}", e)))?;
-
-    let (client_reader, client_writer) = client_stream.into_split();
-    let (server_reader, server_writer) = server_stream.into_split();
-
-    let client_to_server = relay_stream(client_reader, server_writer, shutdown.clone());
-    let server_to_client = relay_stream(server_reader, client_writer, shutdown);
-
-    tokio::select! {
-        result = client_to_server => result?,
-        result = server_to_client => result?,
-    }
-
-    Ok(())
-}
-
-async fn relay_stream(
-    mut read_stream: impl AsyncReadExt + Unpin, mut write_stream: impl AsyncWriteExt + Unpin,
-    shutdown: std::sync::Arc<Notify>,
-) -> Result<(), ProxyError> {
-    let mut buffer = vec![0u8; BUFFER_SIZE];
-
-    loop {
-        tokio::select! {
-            read_result = read_stream.read(&mut buffer) => {
-                match read_result {
-                    Ok(0) => break,
-                    Ok(n) => {
-                        retryable_write(&mut write_stream, &buffer[..n]).await?;
-                    }
-                    Err(e) => return Err(ProxyError::Io(e)),
-                }
-            }
-            _ = shutdown.notified() => {
-                break;
-            }
-        }
-    }
-
-    write_stream.shutdown().await?;
-    Ok(())
-}
-
-async fn retryable_write(
-    writer: &mut (impl AsyncWriteExt + Unpin), buf: &[u8],
-) -> Result<(), ProxyError> {
-    let mut attempts = 0;
-    let mut delay = INITIAL_RETRY_DELAY;
-
-    loop {
-        match writer.write_all(buf).await {
-            Ok(()) => return Ok(()),
-            Err(_) if attempts < MAX_RETRIES => {
-                attempts += 1;
-                time::sleep(delay).await;
-                delay *= 2;
-            }
-            Err(e) => return Err(ProxyError::Io(e)),
-        }
-    }
-}
-
-#[cfg(test)]
-mod tests {
-    use tokio::sync::watch;
-
-    use super::*;
-
-    async fn setup_test_server() -> (u16, watch::Sender<bool>) {
-        let listener = TcpListener::bind("127.0.0.1:0").await.unwrap();
-        let port = listener.local_addr().unwrap().port();
-        let (shutdown_tx, shutdown_rx) = watch::channel(false);
-
-        tokio::spawn(async move {
-            while !*shutdown_rx.borrow() {
-                if let Ok((mut socket, _)) = listener.accept().await {
-                    let (mut reader, mut writer) = socket.split();
-                    let mut buf = vec![0; 1024];
-                    if let Ok(n) = reader.read(&mut buf).await {
-                        writer.write_all(&buf[..n]).await.unwrap();
-                    }
-                }
-            }
-        });
-
-        (port, shutdown_tx)
-    }
-
-    #[tokio::test]
-    async fn test_proxy_relay() {
-        let (echo_port, _shutdown) = setup_test_server().await;
-
-        let config = ProxyConfig::new(
-            "127.0.0.1".to_string(),
-            echo_port,
-            0,
-            crate::proxy::config::ProxyType::Http,
-        );
-
-        let shutdown = std::sync::Arc::new(Notify::new());
-
-        tokio::spawn(async move {
-            start_proxy(config, shutdown).await.unwrap();
-        });
-    }
-}
diff --git a/crates/kftray-server/src/proxy/mod.rs b/crates/kftray-server/src/proxy/mod.rs
index a097984..9f893d0 100644
--- a/crates/kftray-server/src/proxy/mod.rs
+++ b/crates/kftray-server/src/proxy/mod.rs
@@ -1,5 +1,9 @@
 pub mod config;
 pub mod error;
-pub mod http;
+pub mod server;
 pub mod tcp;
+pub mod traits;
 pub mod udp;
+
+#[cfg(test)]
+mod test_utils;
diff --git a/crates/kftray-server/src/proxy/server.rs b/crates/kftray-server/src/proxy/server.rs
new file mode 100644
index 0000000..9840ce9
--- /dev/null
+++ b/crates/kftray-server/src/proxy/server.rs
@@ -0,0 +1,60 @@
+use std::sync::Arc;
+
+use log::info;
+use tokio::sync::Notify;
+
+use crate::proxy::{
+    config::{
+        ProxyConfig,
+        ProxyType,
+    },
+    error::ProxyError,
+    tcp::TcpProxy,
+    traits::ProxyHandler,
+    udp::UdpProxy,
+};
+
+/// Main proxy server that manages the lifecycle of proxy connections
+pub struct ProxyServer {
+    /// Server configuration
+    config: ProxyConfig,
+    /// Shutdown signal notifier
+    shutdown: Arc<Notify>,
+    /// Protocol-specific proxy handler (TCP or UDP)
+    handler: Box<dyn ProxyHandler>,
+}
+
+impl ProxyServer {
+    /// Creates a new proxy server instance with the given configuration
+    ///
+    /// # Parameters
+    /// * `config` - Server configuration including proxy type and port settings
+    pub fn new(config: ProxyConfig) -> Self {
+        let handler: Box<dyn ProxyHandler> = match config.proxy_type {
+            ProxyType::Tcp => Box::new(TcpProxy::new()),
+            ProxyType::Udp => Box::new(UdpProxy::new()),
+        };
+
+        Self {
+            config,
+            shutdown: Arc::new(Notify::new()),
+            handler,
+        }
+    }
+
+    /// Starts the proxy server and begins handling connections
+    ///
+    /// # Returns
+    /// * `Result<(), ProxyError>` - Success if server runs and shuts down cleanly
+    pub async fn run(&self) -> Result<(), ProxyError> {
+        self.handler
+            .start(self.config.clone(), self.shutdown.clone())
+            .await
+    }
+
+    /// Initiates a graceful shutdown of the proxy server
+    pub fn shutdown(&self) {
+        info!("Initiating server shutdown");
+        self.shutdown.notify_waiters();
+    }
+}
diff --git a/crates/kftray-server/src/proxy/tcp.rs b/crates/kftray-server/src/proxy/tcp.rs
index 4806607..1b22a4a 100644
--- a/crates/kftray-server/src/proxy/tcp.rs
+++ b/crates/kftray-server/src/proxy/tcp.rs
@@ -1,179 +1,291 @@
+use std::{
+    net::SocketAddr,
+    sync::Arc,
+    time::Duration,
+};
+
+use async_trait::async_trait;
 use log::{
     error,
     info,
 };
 use tokio::{
-    io::{
-        AsyncReadExt,
-        AsyncWriteExt,
-    },
+    io::copy_bidirectional,
     net::{
         TcpListener,
         TcpStream,
     },
     sync::Notify,
+    time::timeout,
 };
 
 use crate::proxy::{
     config::ProxyConfig,
     error::ProxyError,
+    traits::ProxyHandler,
 };
 
-const BUFFER_SIZE: usize = 65536;
-
-pub async fn start_proxy(
-    config: ProxyConfig, shutdown: std::sync::Arc<Notify>,
-) -> Result<(), ProxyError> {
-    let listener = TcpListener::bind(format!("0.0.0.0:{}", config.proxy_port)).await?;
-    info!("TCP Proxy started on port {}", config.proxy_port);
-
-    loop {
-        tokio::select! {
-            accept_result = listener.accept() => {
-                match accept_result {
-                    Ok((client_stream, addr)) => {
-                        info!("Accepted connection from {}", addr);
-                        let config = config.clone();
-                        let shutdown = shutdown.clone();
-
-                        tokio::spawn(async move {
-                            if let Err(e) = handle_client(client_stream, config, shutdown).await {
-                                error!("Error handling client: {}", e);
-                            }
-                        });
-                    }
-                    Err(e) => error!("Failed to accept connection: {}", e),
-                }
+/// TCP proxy implementation that forwards TCP connections to a target server
+#[derive(Clone)]
+pub struct TcpProxy;
+
+impl TcpProxy {
+    /// Creates a new TCP proxy instance
+    pub fn new() -> Self {
+        Self
+    }
+
+    /// Establishes connection to the target server with timeout
+    ///
+    /// # Parameters
+    /// * `config` - Proxy configuration containing target details
+    ///
+    /// # Returns
+    /// * `Result<TcpStream, ProxyError>` - Connected stream or error
+    async fn connect_to_target(&self, config: &ProxyConfig) -> Result<TcpStream, ProxyError> {
+        const CONNECTION_TIMEOUT: Duration = Duration::from_secs(5);
+
+        match timeout(
+            CONNECTION_TIMEOUT,
+            TcpStream::connect(format!("{}:{}", config.target_host, config.target_port)),
+        )
+        .await
+        {
+            Ok(Ok(stream)) => {
+                info!(
+                    "Connected to target {}:{}",
+                    config.target_host, config.target_port
+                );
+                Ok(stream)
             }
-            _ = shutdown.notified() => {
-                info!("Shutdown signal received, stopping TCP proxy");
-                break;
+            Ok(Err(e)) => {
+                error!("Failed to connect to target: {}", e);
+                Err(ProxyError::Connection(format!(
+                    "Failed to connect to target: {}",
+                    e
+                )))
             }
+            Err(_) => Err(ProxyError::Connection("Connection timeout".into())),
         }
     }
 
-    Ok(())
-}
-
-async fn handle_client(
-    client_stream: TcpStream, config: ProxyConfig, shutdown: std::sync::Arc<Notify>,
-) -> Result<(), ProxyError> {
-    let server_stream =
-        TcpStream::connect(format!("{}:{}", config.target_host, config.target_port))
-            .await
-            .map_err(|e| ProxyError::Connection(format!("Failed to connect to target: {}", e)))?;
+    /// Handles an individual TCP proxy connection
+    ///
+    /// Copies data bidirectionally between the client and target server
+    ///
+    /// # Parameters
+    /// * `inbound` - Client connection stream
+    /// * `config` - Proxy configuration
+    async fn handle_tcp_connection(
+        &self,
+        inbound: TcpStream,
+        config: &ProxyConfig,
+    ) -> Result<(), ProxyError> {
+        let outbound = self.connect_to_target(config).await?;
+        let (mut inbound, mut outbound) = (inbound, outbound);
 
-    info!(
-        "Connected to target {}:{}",
-        config.target_host, config.target_port
-    );
+        match copy_bidirectional(&mut inbound, &mut outbound).await {
+            Ok((from_client, from_server)) => {
+                info!(
+                    "Connection closed. Bytes from client: {}, from server: {}",
+                    from_client, from_server
+                );
+                Ok(())
+            }
+            Err(e) if Self::is_connection_reset(&e) => {
+                info!("Connection closed by peer");
+                Ok(())
+            }
+            Err(e) => {
+                error!("Connection error: {}", e);
+                Err(ProxyError::Io(e))
+            }
+        }
+    }
 
-    let (client_reader, client_writer) = client_stream.into_split();
-    let (server_reader, server_writer) = server_stream.into_split();
+    fn is_connection_reset(error: &std::io::Error) -> bool {
+        matches!(
+            error.kind(),
+            std::io::ErrorKind::BrokenPipe
+                | std::io::ErrorKind::ConnectionReset
+                | std::io::ErrorKind::ConnectionAborted
+        )
+    }
+}
 
-    let client_to_server = relay_stream(client_reader, server_writer, shutdown.clone());
-    let server_to_client = relay_stream(server_reader, client_writer, shutdown);
+#[async_trait]
+impl ProxyHandler for TcpProxy {
+    /// Starts the proxy server with the given configuration and shutdown signal.
+    ///
+    /// # Parameters
+    /// * `config` - Configuration containing proxy settings like ports and target details
+    /// * `shutdown` - Notification mechanism to signal when the proxy should stop
+    ///
+    /// # Returns
+    /// * `Result<(), ProxyError>` - Success if proxy runs and shuts down cleanly, or error details
+    async fn start(&self, config: ProxyConfig, shutdown: Arc<Notify>) -> Result<(), ProxyError> {
+        let addr: SocketAddr = format!("0.0.0.0:{}", config.proxy_port).parse()?;
+        let listener = TcpListener::bind(addr).await?;
 
-    tokio::select! {
-        result = client_to_server => result?,
-        result = server_to_client => result?,
-    }
+        info!("TCP Proxy started on port {}", config.proxy_port);
 
-    Ok(())
-}
+        loop {
+            tokio::select! {
+                accept_result = listener.accept() => {
+                    match accept_result {
+                        Ok((stream, addr)) => {
+                            info!("Accepted connection from {}", addr);
+                            let config = config.clone();
+                            let proxy = self.clone();
 
-async fn relay_stream(
-    mut read_stream: impl AsyncReadExt + Unpin, mut write_stream: impl AsyncWriteExt + Unpin,
-    shutdown: std::sync::Arc<Notify>,
-) -> Result<(), ProxyError> {
-    let mut buffer = vec![0u8; BUFFER_SIZE];
-
-    loop {
-        tokio::select! {
-            read_result = read_stream.read(&mut buffer) => {
-                match read_result {
-                    Ok(0) => break, // EOF
-                    Ok(n) => {
-                        write_stream.write_all(&buffer[..n]).await
-                            .map_err(ProxyError::Io)?;
+                            tokio::spawn(async move {
+                                if let Err(e) = proxy.handle_tcp_connection(stream, &config).await {
+                                    error!("Connection error for {}: {}", addr, e);
+                                }
+                            });
+                        }
+                        Err(e) => error!("Failed to accept connection: {}", e),
                     }
-                    Err(e) => return Err(ProxyError::Io(e)),
                 }
-            }
-            _ = shutdown.notified() => {
-                break;
+                _ = shutdown.notified() => {
+                    info!("Shutdown signal received, stopping TCP proxy");
+                    break;
+                }
             }
         }
-    }
 
-    write_stream.shutdown().await?;
-    Ok(())
+        Ok(())
+    }
 }
 
 #[cfg(test)]
 mod tests {
-    use std::net::SocketAddr;
+    use super::*;
+    use crate::proxy::{
+        config::ProxyType,
+        test_utils::{self, TestServer},
+    };
+    use tokio::{
+        net::TcpStream,
+        io::{AsyncReadExt, AsyncWriteExt},
+    };
+    use std::{time::Duration, net::SocketAddr};
 
-    use tokio::net::TcpSocket;
+    const TEST_TIMEOUT: Duration = Duration::from_secs(5);
 
-    use super::*;
+    async fn setup_proxy() -> (TestServer, Arc<Notify>, SocketAddr) {
+        let echo_server = test_utils::setup_test_tcp_echo_server().await;
+        let proxy = TcpProxy::new();
+        let shutdown = Arc::new(Notify::new());
+        let shutdown_clone = shutdown.clone();
 
-    async fn setup_test_server() -> (SocketAddr, std::sync::Arc<Notify>) {
-        let socket = TcpSocket::new_v4().unwrap();
-        let addr: SocketAddr = "127.0.0.1:0".parse().unwrap();
-        socket.bind(addr).unwrap();
-        let listener = socket.listen(1024).unwrap();
+        // Bind to 127.0.0.1:0 first to get an available port
+        let listener = TcpListener::bind("127.0.0.1:0").await.unwrap();
         let addr = listener.local_addr().unwrap();
-        let shutdown = std::sync::Arc::new(Notify::new());
-        let shutdown_clone = shutdown.clone();
+        drop(listener);
+
+        let config = ProxyConfig::builder()
+            .target_host(echo_server.addr().ip().to_string())
+            .target_port(echo_server.addr().port())
+            .proxy_port(addr.port())
+            .proxy_type(ProxyType::Tcp)
+            .build()
+            .unwrap();
 
         tokio::spawn(async move {
-            while let Ok((mut socket, _)) = listener.accept().await {
-                let (mut reader, mut writer) = socket.split();
-                let mut buf = vec![0; 1024];
-                while let Ok(n) = reader.read(&mut buf).await {
-                    if n == 0 {
-                        break;
-                    }
-                    writer.write_all(&buf[..n]).await.unwrap();
-                }
-            }
+            let _ = proxy.start(config, shutdown).await;
         });
 
-        (addr, shutdown_clone)
+        // Wait for the proxy to be ready
+        assert!(test_utils::wait_for_port(addr).await, "Proxy failed to start");
+
+        (echo_server, shutdown_clone, addr)
     }
 
     #[tokio::test]
-    async fn test_tcp_proxy() {
-        let (server_addr, _shutdown) = setup_test_server().await;
+    async fn test_tcp_proxy_echo() {
+        // Arrange
+        let (echo_server, shutdown, proxy_addr) = setup_proxy().await;
+        let test_data = b"Hello, proxy!";
+        let mut response = vec![0; test_data.len()];
 
-        let config = ProxyConfig::new(
-            server_addr.ip().to_string(),
-            server_addr.port(),
-            0,
-            crate::proxy::config::ProxyType::Tcp,
-        );
+        // Act
+        let mut stream = TcpStream::connect(proxy_addr).await.unwrap();
+        stream.write_all(test_data).await.unwrap();
+        stream.flush().await.unwrap();
 
-        let shutdown = std::sync::Arc::new(Notify::new());
-        let shutdown_clone = shutdown.clone();
+        let n = tokio::time::timeout(
+            TEST_TIMEOUT,
+            stream.read_exact(&mut response)
+        ).await.unwrap().unwrap();
 
-        tokio::spawn(async move {
-            start_proxy(config, shutdown).await.unwrap();
-        });
+        // Assert
+        assert_eq!(n, test_data.len());
+        assert_eq!(&response, test_data);
 
-        tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
+        // Cleanup
+        shutdown.notify_one();
+        echo_server.shutdown();
+    }
 
-        // Test connection and data transfer
-        let mut client = TcpStream::connect("127.0.0.1:0").await.unwrap();
+    #[tokio::test]
+    async fn test_tcp_proxy_large_data() {
+        // Arrange
+        let (echo_server, shutdown, proxy_addr) = setup_proxy().await;
+        let test_data = vec![0x55; 1024 * 1024]; // 1MB of data
+        let mut response = vec![0; test_data.len()];
 
-        let test_data = b"Hello, proxy!";
-        client.write_all(test_data).await.unwrap();
+        // Act
+        let mut stream = TcpStream::connect(proxy_addr).await.unwrap();
+        stream.write_all(&test_data).await.unwrap();
+        stream.flush().await.unwrap();
 
-        let mut response = vec![0; test_data.len()];
-        client.read_exact(&mut response).await.unwrap();
+        let n = tokio::time::timeout(
+            TEST_TIMEOUT,
+            stream.read_exact(&mut response)
+        ).await.unwrap().unwrap();
 
-        assert_eq!(&response, test_data);
+        // Assert
+        assert_eq!(n, test_data.len());
+        assert_eq!(response, test_data);
+
+        // Cleanup
+        shutdown.notify_one();
+        echo_server.shutdown();
+    }
+
+    #[tokio::test]
+    async fn test_tcp_proxy_multiple_clients() {
+        // Arrange
+        let (echo_server, shutdown, proxy_addr) = setup_proxy().await;
+        let test_data = b"Hello from client";
+        let client_count = 5;
+        let mut handles = Vec::new();
+
+        // Act
+        for i in 0..client_count {
+            let addr = proxy_addr;
+            let data = test_data.to_vec();
+            handles.push(tokio::spawn(async move {
+                let mut stream = TcpStream::connect(addr).await.unwrap();
+                stream.write_all(&data).await.unwrap();
+                stream.flush().await.unwrap();
+
+                let mut response = vec![0; data.len()];
+                let n = stream.read_exact(&mut response).await.unwrap();
+                (i, n, response)
+            }));
+        }
+
+        // Assert
+        for handle in handles {
+            let (client_id, n, response) = handle.await.unwrap();
+            assert_eq!(n, test_data.len(), "Client {} received wrong data length", client_id);
+            assert_eq!(&response, test_data, "Client {} received incorrect data", client_id);
+        }
 
-        shutdown_clone.notify_one();
+        // Cleanup
+        shutdown.notify_one();
+        echo_server.shutdown();
     }
 }
diff --git a/crates/kftray-server/src/proxy/test_utils.rs b/crates/kftray-server/src/proxy/test_utils.rs
new file mode 100644
index 0000000..8562bb2
--- /dev/null
+++ b/crates/kftray-server/src/proxy/test_utils.rs
@@ -0,0 +1,88 @@
+use std::net::SocketAddr;
+use tokio::{
+    net::{TcpListener, UdpSocket},
+    sync::oneshot,
+    io::{AsyncReadExt, AsyncWriteExt},
+};
+
+use tokio::net::TcpStream;
+use tokio::time::Duration;
+
+pub const TEST_BUFFER_SIZE: usize = 1024;
+
+pub struct TestServer {
+    pub addr: SocketAddr,
+    shutdown_tx: oneshot::Sender<()>,
+}
+
+impl TestServer {
+    pub fn addr(&self) -> SocketAddr {
+        self.addr
+    }
+
+    pub fn shutdown(self) {
+        let _ = self.shutdown_tx.send(());
+    }
+}
+
+pub async fn wait_for_port(addr: SocketAddr) -> bool {
+    for _ in 0..50 {
+        if let Ok(stream) = TcpStream::connect(addr).await {
+            drop(stream);
+            return true;
+        }
+        tokio::time::sleep(Duration::from_millis(100)).await;
+    }
+    false
+}
+
+pub async fn setup_test_tcp_echo_server() -> TestServer {
+    let listener = TcpListener::bind("127.0.0.1:0").await.unwrap();
+    let addr = listener.local_addr().unwrap();
+    let (shutdown_tx, mut shutdown_rx) = oneshot::channel();
+
+    tokio::spawn(async move {
+        loop {
+            tokio::select! {
+                accept_result = listener.accept() => {
+                    if let Ok((mut socket, _)) = accept_result {
+                        tokio::spawn(async move {
+                            let mut buf = [0; TEST_BUFFER_SIZE];
+                            while let Ok(n) = socket.read(&mut buf).await {
+                                if n == 0 { break; }
+                                if socket.write_all(&buf[..n]).await.is_err() {
+                                    break;
+                                }
+                            }
+                        });
+                    }
+                }
+                _ = &mut shutdown_rx => break,
+            }
+        }
+    });
+
+    TestServer { addr, shutdown_tx }
+}
+
+pub async fn setup_test_udp_echo_server() -> TestServer {
+    let socket = UdpSocket::bind("127.0.0.1:0").await.unwrap();
+    let addr = socket.local_addr().unwrap();
+    let (shutdown_tx, mut shutdown_rx) = oneshot::channel();
+
+    tokio::spawn(async move {
+        let mut buf = vec![0; TEST_BUFFER_SIZE];
+        loop {
+            tokio::select! {
+                result = socket.recv_from(&mut buf) => {
+                    if let Ok((n, peer)) = result {
+                        let _ = socket.send_to(&buf[..n], peer).await;
+                    }
+                }
+                _ = &mut shutdown_rx => break,
+            }
+        }
+    });
+
+    TestServer { addr, shutdown_tx }
+}
diff --git a/crates/kftray-server/src/proxy/traits.rs b/crates/kftray-server/src/proxy/traits.rs
new file mode 100644
index 0000000..1911db9
--- /dev/null
+++ b/crates/kftray-server/src/proxy/traits.rs
@@ -0,0 +1,24 @@
+use std::sync::Arc;
+
+use async_trait::async_trait;
+use tokio::sync::Notify;
+
+use crate::proxy::{
+    config::ProxyConfig,
+    error::ProxyError,
+};
+
+/// Defines the core proxy handling behavior that must be implemented by concrete proxy types.
+/// This trait enables a common interface for different proxy implementations (TCP, UDP).
+#[async_trait]
+pub trait ProxyHandler: Send + Sync {
+    /// Starts the proxy server with the given configuration and shutdown signal.
+    ///
+    /// # Parameters
+    /// * `config` - Configuration containing proxy settings like ports and target details
+    /// * `shutdown` - Notification mechanism to signal when the proxy should stop
+    ///
+    /// # Returns
+    /// * `Result<(), ProxyError>` - Success if proxy runs and shuts down cleanly, or error details
+    async fn start(&self, config: ProxyConfig, shutdown: Arc<Notify>) -> Result<(), ProxyError>;
+}
diff --git a/crates/kftray-server/src/proxy/udp.rs b/crates/kftray-server/src/proxy/udp.rs
index e6aa841..5c83bb6 100644
--- a/crates/kftray-server/src/proxy/udp.rs
+++ b/crates/kftray-server/src/proxy/udp.rs
@@ -1,9 +1,11 @@
-use byteorder::{
-    BigEndian,
-    ReadBytesExt,
-    WriteBytesExt,
+use std::{
+    sync::Arc,
+    time::Duration,
 };
+
+use async_trait::async_trait;
 use log::{
+    debug,
     error,
     info,
 };
@@ -23,186 +25,316 @@ use tokio::{
 use crate::proxy::{
     config::ProxyConfig,
     error::ProxyError,
+    traits::ProxyHandler,
 };
 
-pub async fn start_proxy(
-    config: ProxyConfig, shutdown: std::sync::Arc<Notify>,
-) -> Result<(), ProxyError> {
-    let listener = TcpListener::bind(format!("0.0.0.0:{}", config.proxy_port)).await?;
-    info!("UDP-over-TCP Proxy started on port {}", config.proxy_port);
-
-    loop {
-        tokio::select! {
-            accept_result = listener.accept() => {
-                match accept_result {
-                    Ok((stream, addr)) => {
-                        info!("Accepted TCP connection from {}", addr);
-                        let config = config.clone();
-                        let shutdown = shutdown.clone();
-
-                        tokio::spawn(async move {
-                            if let Err(e) = handle_client(stream, config, shutdown).await {
-                                error!("Error handling client: {}", e);
-                            }
-                        });
-                    }
-                    Err(e) => error!("Failed to accept connection: {}", e),
-                }
-            }
-            _ = shutdown.notified() => {
-                info!("Shutdown signal received, stopping UDP proxy");
-                break;
-            }
-        }
-    }
-
-    Ok(())
-}
-
-async fn handle_client(
-    tcp_stream: TcpStream, config: ProxyConfig, shutdown: std::sync::Arc<Notify>,
-) -> Result<(), ProxyError> {
-    let udp_socket = UdpSocket::bind("0.0.0.0:0").await?;
-    udp_socket
-        .connect((config.target_host, config.target_port))
-        .await?;
+const UDP_TIMEOUT: Duration = Duration::from_secs(5);
+const MAX_UDP_PAYLOAD_SIZE: usize = 65507;
 
-    let (tcp_reader, tcp_writer) = tcp_stream.into_split();
-    let udp_socket = std::sync::Arc::new(udp_socket);
+/// UDP proxy implementation that tunnels UDP traffic over TCP connections
+#[derive(Clone)]
+pub struct UdpProxy;
 
-    let tcp_to_udp = handle_tcp_to_udp(tcp_reader, udp_socket.clone(), shutdown.clone());
-    let udp_to_tcp = handle_udp_to_tcp(udp_socket, tcp_writer, shutdown);
+impl UdpProxy {
+    /// Creates a new UDP proxy instance
+    pub fn new() -> Self {
+        Self
+    }
 
-    tokio::select! {
-        result = tcp_to_udp => result?,
-        result = udp_to_tcp => result?,
+    /// Creates and connects a UDP socket to the target server
+    ///
+    /// # Parameters
+    /// * `config` - Proxy configuration containing target details
+    ///
+    /// # Returns
+    /// * `Result<UdpSocket, ProxyError>` - Connected socket or error
+    async fn create_udp_socket(&self, config: &ProxyConfig) -> Result<UdpSocket, ProxyError> {
+        let socket = UdpSocket::bind("0.0.0.0:0").await?;
+        socket
+            .connect((config.target_host.as_str(), config.target_port))
+            .await?;
+
+        debug!(
+            "Connected UDP socket to {}:{}",
+            config.target_host, config.target_port
+        );
+        Ok(socket)
     }
 
-    Ok(())
-}
+    /// Handles a TCP connection carrying tunneled UDP traffic
+    ///
+    /// Forwards UDP packets between the TCP client and target UDP server
+    ///
+    /// # Parameters
+    /// * `tcp_stream` - Client TCP connection
+    /// * `config` - Proxy configuration
+    async fn handle_udp_connection(
+        &self, mut tcp_stream: TcpStream, config: &ProxyConfig,
+    ) -> Result<(), ProxyError> {
+        let udp_socket = self.create_udp_socket(config).await?;
+        let mut size_buf = [0u8; 4];
+
+        loop {
+            match tcp_stream.read_exact(&mut size_buf).await {
+                Ok(_) => {
+                    let size = u32::from_be_bytes(size_buf);
+                    debug!("Read size: {}", size);
+
+                    if size as usize > MAX_UDP_PAYLOAD_SIZE {
+                        let err = ProxyError::InvalidData(format!(
+                            "UDP packet size {} exceeds maximum allowed {}",
+                            size, MAX_UDP_PAYLOAD_SIZE
+                        ));
+                        tcp_stream.write_all(&0u32.to_be_bytes()).await?;
+                        tcp_stream.flush().await?;
+                        return Err(err);
+                    }
 
-async fn handle_tcp_to_udp(
-    mut tcp_reader: impl AsyncReadExt + Unpin, udp_socket: std::sync::Arc<UdpSocket>,
-    shutdown: std::sync::Arc<Notify>,
-) -> Result<(), ProxyError> {
-    let mut size_buf = [0u8; 4];
-
-    loop {
-        tokio::select! {
-            read_result = tcp_reader.read_exact(&mut size_buf) => {
-                match read_result {
-                    Ok(_) => {
-                        let mut rdr = &size_buf[..];
-                        let size = ReadBytesExt::read_u32::<BigEndian>(&mut rdr)
-                            .map_err(ProxyError::Io)?;
-                        let mut buffer = vec![0u8; size as usize];
-                        tcp_reader.read_exact(&mut buffer).await?;
-                        udp_socket.send(&buffer).await?;
+                    let mut buffer = vec![0u8; size as usize];
+                    match tcp_stream.read_exact(&mut buffer).await {
+                        Ok(_) => {
+                            debug!("Received {} bytes from TCP", size);
+                            udp_socket.send(&buffer).await?;
+                            debug!("Sent {} bytes to UDP", size);
+
+                            self.handle_udp_response(&udp_socket, &mut tcp_stream)
+                                .await?;
+                        }
+                        Err(e) if e.kind() == std::io::ErrorKind::UnexpectedEof => {
+                            debug!("TCP connection closed while reading payload");
+                            break;
+                        }
+                        Err(e) => {
+                            error!("Error reading TCP payload: {}", e);
+                            return Err(ProxyError::Io(e));
+                        }
                     }
-                    Err(e) => return Err(ProxyError::Io(e)),
                 }
-            }
-            _ = shutdown.notified() => {
-                break;
+                Err(e) if e.kind() == std::io::ErrorKind::UnexpectedEof => {
+                    debug!("TCP connection closed");
+                    break;
+                }
+                Err(e) => {
+                    error!("TCP read error: {}", e);
+                    return Err(ProxyError::Io(e));
+                }
             }
         }
+
+        Ok(())
     }
 
-    Ok(())
+    async fn handle_udp_response(
+        &self, udp_socket: &UdpSocket, tcp_stream: &mut TcpStream,
+    ) -> Result<(), ProxyError> {
+        let mut response = vec![0u8; MAX_UDP_PAYLOAD_SIZE];
+
+        match tokio::time::timeout(UDP_TIMEOUT, udp_socket.recv(&mut response)).await {
+            Ok(Ok(n)) => {
+                debug!("Received {} bytes from UDP", n);
+                tcp_stream.write_all(&(n as u32).to_be_bytes()).await?;
+                tcp_stream.write_all(&response[..n]).await?;
+                tcp_stream.flush().await?;
+                debug!("Sent response back to TCP client");
+                Ok(())
+            }
+            Ok(Err(e)) => {
+                error!("UDP receive error: {}", e);
+                Err(ProxyError::Io(e))
+            }
+            Err(_) => {
+                debug!("UDP response timeout");
+                tcp_stream.write_all(&0u32.to_be_bytes()).await?;
+                tcp_stream.flush().await?;
+                Ok(())
+            }
+        }
+    }
 }
 
-async fn handle_udp_to_tcp(
-    udp_socket: std::sync::Arc<UdpSocket>, mut tcp_writer: impl AsyncWriteExt + Unpin,
-    shutdown: std::sync::Arc<Notify>,
-) -> Result<(), ProxyError> {
-    let mut buffer = vec![0u8; 65535];
-
-    loop {
-        tokio::select! {
-            recv_result = udp_socket.recv(&mut buffer) => {
-                match recv_result {
-                    Ok(size) => {
-                        let mut size_buf = Vec::new();
-                        WriteBytesExt::write_u32::<BigEndian>(&mut size_buf, size as u32)
-                            .map_err(ProxyError::Io)?;
-                        tcp_writer.write_all(&size_buf).await?;
-                        tcp_writer.write_all(&buffer[..size]).await?;
-                        tcp_writer.flush().await?;
+#[async_trait]
+impl ProxyHandler for UdpProxy {
+    async fn start(&self, config: ProxyConfig, shutdown: Arc<Notify>) -> Result<(), ProxyError> {
+        let listener = TcpListener::bind(format!("0.0.0.0:{}", config.proxy_port)).await?;
+        info!("UDP-over-TCP Proxy started on port {}", config.proxy_port);
+
+        loop {
+            tokio::select! {
+                accept_result = listener.accept() => {
+                    match accept_result {
+                        Ok((stream, addr)) => {
+                            info!("Accepted connection from {}", addr);
+                            let config = config.clone();
+                            let proxy = self.clone();
+
+                            tokio::spawn(async move {
+                                if let Err(e) = proxy.handle_udp_connection(stream, &config).await {
+                                    error!("Error handling client: {}", e);
+                                }
+                            });
+                        }
+                        Err(e) => error!("Failed to accept connection: {}", e),
                     }
-                    Err(e) => return Err(ProxyError::Io(e)),
                 }
-            }
-            _ = shutdown.notified() => {
-                break;
+                _ = shutdown.notified() => {
+                    info!("Shutdown signal received, stopping UDP proxy");
+                    break;
+                }
             }
         }
-    }
 
-    Ok(())
+        Ok(())
+    }
 }
 
 #[cfg(test)]
 mod tests {
-    use std::net::SocketAddr;
-
-    use tokio::net::UdpSocket;
-
     use super::*;
-
-    async fn setup_test_udp_server() -> (SocketAddr, std::sync::Arc<Notify>) {
-        let socket = UdpSocket::bind("127.0.0.1:0").await.unwrap();
-        let addr = socket.local_addr().unwrap();
-        let shutdown = std::sync::Arc::new(Notify::new());
+    use crate::proxy::{
+        config::ProxyType,
+        test_utils::{self, TestServer},
+    };
+    use tokio::{
+        net::TcpStream,
+        io::{AsyncReadExt, AsyncWriteExt},
+    };
+    use std::{time::Duration, net::SocketAddr};
+
+    const TEST_TIMEOUT: Duration = Duration::from_secs(5);
+
+    async fn setup_proxy() -> (TestServer, Arc<Notify>, SocketAddr) {
+        let echo_server = test_utils::setup_test_udp_echo_server().await;
+        let proxy = UdpProxy::new();
+        let shutdown = Arc::new(Notify::new());
         let shutdown_clone = shutdown.clone();
 
+        let listener = TcpListener::bind("127.0.0.1:0").await.unwrap();
+        let addr = listener.local_addr().unwrap();
+        drop(listener);
+
+        let config = ProxyConfig::builder()
+            .target_host(echo_server.addr().ip().to_string())
+            .target_port(echo_server.addr().port())
+            .proxy_port(addr.port())
+            .proxy_type(ProxyType::Udp)
+            .build()
+            .unwrap();
+
         tokio::spawn(async move {
-            let mut buf = vec![0; 65535];
-            while let Ok((n, peer)) = socket.recv_from(&mut buf).await {
-                socket.send_to(&buf[..n], peer).await.unwrap();
-            }
+            let _ = proxy.start(config, shutdown).await;
         });
 
-        (addr, shutdown_clone)
+
+        assert!(test_utils::wait_for_port(addr).await, "Proxy failed to start");
+
+        (echo_server, shutdown_clone, addr)
     }
 
-    #[tokio::test]
-    async fn test_udp_proxy() {
-        let (server_addr, _shutdown) = setup_test_udp_server().await;
-
-        let config = ProxyConfig::new(
-            server_addr.ip().to_string(),
-            server_addr.port(),
-            0,
-            crate::proxy::config::ProxyType::Udp,
-        );
+    async fn send_udp_packet(stream: &mut TcpStream, data: &[u8]) -> Result<Vec<u8>, ProxyError> {
+        // Send packet size and data
+        stream.write_all(&(data.len() as u32).to_be_bytes()).await?;
+        stream.write_all(data).await?;
+        stream.flush().await?;
 
-        let shutdown = std::sync::Arc::new(Notify::new());
-        let shutdown_clone = shutdown.clone();
+        // Read response size
+        let mut size_buf = [0u8; 4];
+        stream.read_exact(&mut size_buf).await?;
+        let response_size = u32::from_be_bytes(size_buf) as usize;
 
-        tokio::spawn(async move {
-            start_proxy(config, shutdown).await.unwrap();
-        });
+        // If response size is 0, this indicates an error
+        if response_size == 0 {
+            return Err(ProxyError::InvalidData("Oversized packet".into()));
+        }
+
+        // Read response data
+        let mut response = vec![0u8; response_size];
+        stream.read_exact(&mut response).await?;
 
-        tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
+        Ok(response)
+    }
 
-        let mut client = TcpStream::connect("127.0.0.1:0").await.unwrap();
+    #[tokio::test]
+    async fn test_udp_proxy_echo() {
+        // Arrange
+        let (echo_server, shutdown, proxy_addr) = setup_proxy().await;
         let test_data = b"Hello, UDP proxy!";
 
-        let mut size_buf = Vec::new();
-        WriteBytesExt::write_u32::<BigEndian>(&mut size_buf, test_data.len() as u32).unwrap();
-        client.write_all(&size_buf).await.unwrap();
-        client.write_all(test_data).await.unwrap();
+        // Act
+        let mut stream = TcpStream::connect(proxy_addr).await.unwrap();
+        let response = tokio::time::timeout(
+            TEST_TIMEOUT,
+            send_udp_packet(&mut stream, test_data)
+        ).await.unwrap().unwrap();
+
+        // Assert
+        assert_eq!(response, test_data);
+
+        // Cleanup
+        shutdown.notify_one();
+        echo_server.shutdown();
+    }
+
+    #[tokio::test]
+    async fn test_udp_proxy_large_packet() {
+        // Arrange
+        let (echo_server, shutdown, proxy_addr) = setup_proxy().await;
+        let test_data = vec![0x55; 1024]; // 1KB packet
+
+        // Act
+        let mut stream = TcpStream::connect(proxy_addr).await.unwrap();
+        let response = tokio::time::timeout(
+            TEST_TIMEOUT,
+            send_udp_packet(&mut stream, &test_data)
+        ).await.unwrap().unwrap();
+
+        // Assert
+        assert_eq!(response, test_data);
+
+        // Cleanup
+        shutdown.notify_one();
+        echo_server.shutdown();
+    }
+
+    #[tokio::test]
+    async fn test_udp_proxy_multiple_packets() {
+        // Arrange
+        let (echo_server, shutdown, proxy_addr) = setup_proxy().await;
+        let test_data = b"Packet";
+        let packet_count = 5;
+
+        // Act
+        let mut stream = TcpStream::connect(proxy_addr).await.unwrap();
+
+        for i in 0..packet_count {
+            let response = tokio::time::timeout(
+                TEST_TIMEOUT,
+                send_udp_packet(&mut stream, test_data)
+            ).await.unwrap().unwrap();
+
+            // Assert
+            assert_eq!(response, test_data, "Packet {} was not echoed correctly", i);
+        }
 
-        let mut response_size = [0u8; 4];
-        client.read_exact(&mut response_size).await.unwrap();
-        let mut rdr = &response_size[..];
-        let response_len = ReadBytesExt::read_u32::<BigEndian>(&mut rdr).unwrap();
+        // Cleanup
+        shutdown.notify_one();
+        echo_server.shutdown();
+    }
+
+    #[tokio::test]
+    async fn test_udp_proxy_oversized_packet() {
+        // Arrange
+        let (echo_server, shutdown, proxy_addr) = setup_proxy().await;
+        let oversized_data = vec![0; MAX_UDP_PAYLOAD_SIZE + 1];
 
-        let mut response = vec![0; response_len as usize];
-        client.read_exact(&mut response).await.unwrap();
+        // Act
+        let mut stream = TcpStream::connect(proxy_addr).await.unwrap();
+        let result = send_udp_packet(&mut stream, &oversized_data).await;
 
-        assert_eq!(&response, test_data);
+        // Assert
+        assert!(matches!(result, Err(ProxyError::InvalidData(_))));
 
-        shutdown_clone.notify_one();
+        // Cleanup
+        shutdown.notify_one();
+        echo_server.shutdown();
     }
 }
diff --git a/hacks/server/push_docker_server.sh b/hacks/server/push_docker_server.sh
new file mode 100755
index 0000000..2cbd684
--- /dev/null
+++ b/hacks/server/push_docker_server.sh
@@ -0,0 +1,22 @@
+#!/bin/bash
+
+if [ -z "$1" ]; then
+  echo "Usage: $0 <tag>"
+  exit 1
+fi
+
+TAG=$1
+
+CURRENT_DIR=$(pwd)
+KFTRAY_SERVER_DIR="$CURRENT_DIR/crates/kftray-server"
+
+
+cd "$KFTRAY_SERVER_DIR" || exit
+
+docker buildx build --platform linux/amd64 -t ghcr.io/hcavarsan/kftray-server:"$TAG" --load .
+
+
+cd "$CURRENT_DIR" || exit
+
+
+docker push ghcr.io/hcavarsan/kftray-server:"$TAG"
diff --git a/hacks/server/test_proxy.sh b/hacks/server/test_proxy.sh
new file mode 100755
index 0000000..e7df23b
--- /dev/null
+++ b/hacks/server/test_proxy.sh
@@ -0,0 +1,284 @@
+#!/bin/bash
+
+readonly TCP_CONTAINER="kftray-tcp-proxy"
+readonly UDP_CONTAINER="kftray-udp-proxy"
+readonly MAX_RETRIES=3
+readonly HEALTH_CHECK_TIMEOUT=30
+export LOG_PREFIX
+LOG_PREFIX="[$(date -u '+%Y-%m-%d %H:%M:%S UTC')]"
+
+declare -a CONTAINERS
+declare -a BG_PIDS
+declare -a PIPES
+START_TIME=$(date +%s)
+WAIT_MODE=false
+
+TCP_TEST_RESULT="SKIPPED"
+UDP_TEST_RESULT="SKIPPED"
+
+log_info() { echo "$LOG_PREFIX INFO: $*" | sed 's/\x1B\[[0-9;]*[JKmsu]//g'; }
+log_warning() { echo "$LOG_PREFIX WARNING: $*" >&2 | sed 's/\x1B\[[0-9;]*[JKmsu]//g'; }
+log_error() { echo "$LOG_PREFIX ERROR: $*" >&2 | sed 's/\x1B\[[0-9;]*[JKmsu]//g'; }
+log_debug() { echo "$LOG_PREFIX DEBUG: $*" | sed 's/\x1B\[[0-9;]*[JKmsu]//g'; }
+
+handle_error() {
+	local exit_code=$1
+	local error_msg=$2
+	if [ "$exit_code" -ne 0 ]; then
+		log_error "$error_msg (Exit code: $exit_code)"
+		cleanup
+		exit 1
+	fi
+}
+
+setup_containers() {
+	log_info "Building kftray-server image..."
+	(cd "crates/kftray-server" && docker build -t kftray-server . >/dev/null 2>&1) ||
+		handle_error $? "Failed to build Docker image"
+
+	start_proxy_container "$TCP_CONTAINER" "tcp" "httpbin.org" "80" "8080"
+	start_proxy_container "$UDP_CONTAINER" "udp" "8.8.8.8" "53" "8082"
+}
+
+start_proxy_container() {
+	local container_name=$1
+	local proxy_type=$2
+	local remote_addr=$3
+	local remote_port=$4
+	local local_port=$5
+
+	log_info "Starting $proxy_type proxy to $remote_addr:$remote_port..."
+	docker run -d --name "$container_name" \
+		-p "$local_port:8080" \
+		-e REMOTE_ADDRESS="$remote_addr" \
+		-e REMOTE_PORT="$remote_port" \
+		-e LOCAL_PORT=8080 \
+		-e PROXY_TYPE="$proxy_type" \
+		-e RUST_LOG=debug \
+		kftray-server >/dev/null
+
+	handle_error $? "Failed to start $proxy_type proxy container"
+	check_container_health "$container_name"
+	setup_container_logging "$container_name"
+}
+
+check_container_health() {
+	local container_name=$1
+	local attempt=1
+
+	while [ $attempt -le $HEALTH_CHECK_TIMEOUT ]; do
+		if ! docker ps -q -f name="$container_name" >/dev/null; then
+			log_error "Container $container_name failed to start"
+			docker logs "$container_name"
+			return 1
+		fi
+
+		if docker logs "$container_name" 2>&1 | grep -q "started on port"; then
+			log_info "Container $container_name is healthy"
+			return 0
+		fi
+
+		[ $attempt -eq 1 ] && log_debug "Waiting for container $container_name..."
+		[ $((attempt % 5)) -eq 0 ] && log_debug "Still waiting... (attempt $attempt/$HEALTH_CHECK_TIMEOUT)"
+
+		sleep 1
+		((attempt++))
+	done
+
+	log_error "Container $container_name health check failed"
+	docker logs "$container_name"
+	return 1
+}
+
+setup_container_logging() {
+	local container_name=$1
+	local log_file="/tmp/${container_name}.log"
+	local pipe="/tmp/${container_name}.pipe"
+	mkfifo "$pipe" 2>/dev/null
+
+	{ docker logs -f "$container_name" >"$pipe"; } 2>&1 &
+
+	(while read -r line; do
+		local formatted_line
+		formatted_line=${line//$'\x1B'[\[0-9;]*[JKmsu]//}
+		echo "[$container_name] $formatted_line" >>"$log_file"
+	done <"$pipe" >/dev/null 2>&1 &)
+
+	PIPES+=("$pipe")
+	CONTAINERS+=("$container_name")
+}
+
+create_dns_query() {
+	printf '\x12\x34\x01\x00\x00\x01\x00\x00\x00\x00\x00\x00'
+	printf '\x06google\x03com\x00'
+	printf '\x00\x01\x00\x01'
+}
+
+send_dns_query() {
+	local query
+	query=$(create_dns_query)
+	local length=${#query}
+	printf '\x00\x00\x00%b' "\\x$(printf '%02x' "$length")"
+	printf '%s' "$query"
+}
+
+check_dns_response() {
+	local response_size
+	local response
+
+	response_size=$(dd bs=1 count=4 2>/dev/null | xxd -p)
+	[ -z "$response_size" ] && return 1
+
+	response_size=$((16#$response_size))
+	[ "$response_size" -eq 0 ] && return 1
+
+	response=$(dd bs=1 count="$response_size" 2>/dev/null | xxd -p)
+	[ -z "$response" ] && return 1
+
+	if echo "$response" | grep -q "^....8[0-5]"; then
+		return 0
+	fi
+	return 1
+}
+
+run_tcp_tests() {
+	log_info "Running TCP proxy tests..."
+	local status_code
+	local response
+
+	for i in $(seq 1 $MAX_RETRIES); do
+		log_info "TCP test attempt $i/$MAX_RETRIES"
+
+		# Use -i to show request headers
+		response=$(curl -i -v -s -H "Host: httpbin.org" http://localhost:8080/get 2>&1)
+		status_code=$?
+
+		log_debug "Curl exit code: $status_code"
+		log_debug "Full response:"
+		log_debug "$response"
+
+		if echo "$response" | grep -q '"url": "http://httpbin.org/get"'; then
+			TCP_TEST_RESULT="PASSED"
+			return 0
+		fi
+
+		[ "$i" -lt $MAX_RETRIES ] && sleep 2
+	done
+
+	TCP_TEST_RESULT="FAILED"
+	return 1
+}
+
+
+
+run_udp_tests() {
+	log_info "Running UDP proxy tests..."
+
+	for i in $(seq 1 $MAX_RETRIES); do
+		log_info "UDP test attempt $i/$MAX_RETRIES"
+
+		if send_dns_query | nc -w 5 localhost 8082 | check_dns_response; then
+			UDP_TEST_RESULT="PASSED"
+			return 0
+		fi
+
+		[ "$i" -lt $MAX_RETRIES ] && sleep 2
+	done
+
+	UDP_TEST_RESULT="FAILED"
+	return 1
+}
+
+cleanup_logs() {
+	for container in "${CONTAINERS[@]}"; do
+		rm -f "/tmp/${container}.log" 2>/dev/null
+	done
+}
+
+cleanup() {
+	log_info "Cleaning up resources..." >/dev/null
+
+	for container in "${CONTAINERS[@]}"; do
+		if docker ps -q -f name="$container" >/dev/null 2>&1; then
+			docker rm -f "$container" >/dev/null 2>&1
+		fi
+	done
+
+	for pipe in "${PIPES[@]}"; do
+		rm -f "$pipe" >/dev/null 2>&1
+	done
+
+	cleanup_logs >/dev/null 2>&1
+
+	exit 0
+}
+
+print_summary() {
+	local end_time
+	end_time=$(date +%s)
+	local total_time=$((end_time - START_TIME))
+
+	echo
+	echo "=== PROXY TESTS SUMMARY ==="
+	echo "Test completed at: $(date '+%Y-%m-%d %H:%M:%S')"
+	echo "Total duration: ${total_time}s"
+	echo
+	echo "TCP Proxy (localhost:8080 -> httpbin.org:80): $TCP_TEST_RESULT"
+	echo "UDP Proxy (localhost:8082 -> 8.8.8.8:53): $UDP_TEST_RESULT"
+	echo "=================================="
+
+	if [[ "$TCP_TEST_RESULT" == "FAILED" ||  "$UDP_TEST_RESULT" == "FAILED" ]]; then
+		echo
+		echo "=== DETAILED LOGS FOR FAILED TESTS ==="
+		for container in "${CONTAINERS[@]}"; do
+			if [[ -f "/tmp/${container}.log" ]]; then
+				echo
+				echo "Last 10 lines from $container:"
+				tail -n 10 "/tmp/${container}.log"
+			fi
+		done
+		echo "=================================="
+	fi
+	echo
+}
+
+main() {
+	trap 'cleanup >/dev/null 2>&1' INT TERM EXIT
+
+	while [[ $# -gt 0 ]]; do
+		case $1 in
+		--wait)
+			WAIT_MODE=true
+			shift
+			;;
+		*)
+			log_error "Unknown parameter: $1"
+			exit 1
+			;;
+		esac
+	done
+
+	setup_containers
+	run_tcp_tests
+	run_udp_tests
+
+	print_summary
+
+	if [ "$WAIT_MODE" = true ]; then
+		log_info "Entering monitoring mode. Press Ctrl+C to stop."
+		while true; do
+			for pid in "${BG_PIDS[@]}"; do
+				if ! kill -0 "$pid" 2>/dev/null; then
+					log_error "Logging process $pid died"
+					cleanup
+					exit 1
+				fi
+			done
+			sleep 5
+		done
+	else
+		cleanup
+	fi
+}
+
+main "$@"
diff --git a/package.json b/package.json
index ca72820..3e18d66 100644
--- a/package.json
+++ b/package.json
@@ -13,6 +13,7 @@
 		"lint": "pnpm --filter @kftray/ui run lint && pnpm run lint:back",
 		"lint:back": "cargo clippy --workspace --all-targets --all-features",
 		"lint:front": "pnpm --filter @kftray/ui run lint",
+		"test:server": "bash hacks/test_proxy.sh",
 		"precommit": "pnpm run format && pnpm run lint",
 		"release:minor": "cargo run --bin bump_version minor && git add . && git commit -m 'chore: release new version'",
 		"release:patch": "cargo run --bin bump_version patch && git add . && git commit -m 'chore: release new version'",
