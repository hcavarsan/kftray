use std::collections::HashSet;

use chrono::Utc;
use log::{error, info};
use sqlx::SqlitePool;

use crate::db::get_db_pool;
use crate::models::config_model::Config;
use crate::utils::config::read_configs_with_pool;
use crate::utils::config_state::read_config_states_with_pool;
use crate::utils::settings::{get_env_auto_sync_enabled, get_env_auto_sync_path};

/// Generate .env file content from active port-forward configs
pub async fn generate_env_content(running_only: bool) -> Result<String, String> {
    let pool = get_db_pool().await.map_err(|e| e.to_string())?;
    generate_env_content_with_pool(&pool, running_only).await
}

/// Generate .env file content from active port-forward configs using a specific pool
pub async fn generate_env_content_with_pool(
    pool: &SqlitePool, running_only: bool,
) -> Result<String, String> {
    let configs = read_configs_with_pool(pool).await?;
    let states = read_config_states_with_pool(pool)
        .await
        .map_err(|e| e.to_string())?;

    // Build a set of running config IDs
    let running_ids: HashSet<i64> = states
        .iter()
        .filter(|s| s.is_running)
        .map(|s| s.config_id)
        .collect();

    // Filter configs if running_only is true
    let filtered_configs: Vec<&Config> = configs
        .iter()
        .filter(|c| {
            if running_only {
                c.id.map(|id| running_ids.contains(&id)).unwrap_or(false)
            } else {
                true
            }
        })
        .collect();

    // Detect duplicate names to append namespace for disambiguation
    let mut name_counts: std::collections::HashMap<String, usize> =
        std::collections::HashMap::new();
    for config in &filtered_configs {
        let name = derive_env_var_name(config);
        *name_counts.entry(name).or_insert(0) += 1;
    }

    let mut lines = Vec::new();

    // Add header
    lines.push("# Generated by kftray".to_string());
    lines.push(format!(
        "# Updated: {}",
        Utc::now().format("%Y-%m-%dT%H:%M:%SZ")
    ));
    lines.push(String::new());

    // Generate entries for each config
    for config in &filtered_configs {
        let base_name = derive_env_var_name(config);

        // Append namespace if there are duplicates
        let var_name = if name_counts.get(&base_name).copied().unwrap_or(0) > 1 {
            let namespace = sanitize_env_var_name(&config.namespace);
            if namespace.is_empty() {
                base_name
            } else {
                format!("{base_name}_{namespace}")
            }
        } else {
            base_name
        };

        let host = config
            .local_address
            .as_deref()
            .unwrap_or("127.0.0.1")
            .to_string();
        let port = config.local_port.unwrap_or(0);

        lines.push(format!("{var_name}_HOST={host}"));
        lines.push(format!("{var_name}_PORT={port}"));
    }

    Ok(lines.join("\n"))
}

/// Derive environment variable name from config
/// Priority: alias > service > target
fn derive_env_var_name(config: &Config) -> String {
    let name = config
        .alias
        .as_deref()
        .filter(|s| !s.is_empty())
        .or_else(|| config.service.as_deref().filter(|s| !s.is_empty()))
        .or_else(|| config.target.as_deref().filter(|s| !s.is_empty()))
        .unwrap_or("unknown");

    sanitize_env_var_name(name)
}

/// Write .env file if auto-sync is enabled and path is configured.
/// This is called from the port-forward state change detection loop.
pub async fn write_env_file_if_enabled() -> Result<(), String> {
    let enabled = match get_env_auto_sync_enabled().await {
        Ok(v) => {
            info!("env_auto_sync_enabled from DB: {}", v);
            v
        }
        Err(e) => {
            error!("Failed to get env_auto_sync_enabled: {}", e);
            return Ok(());
        }
    };

    if !enabled {
        info!("Env auto-sync is disabled, skipping");
        return Ok(());
    }

    let path = match get_env_auto_sync_path().await {
        Ok(p) => {
            info!("env_auto_sync_path from DB: {:?}", p);
            p
        }
        Err(e) => {
            error!("Failed to get env_auto_sync_path: {}", e);
            return Ok(());
        }
    };

    let Some(file_path) = path else {
        info!("Env auto-sync enabled but no path configured");
        return Ok(());
    };

    let content = generate_env_content(true).await?;
    let line_count = content.lines().count();
    info!(
        "Writing .env file to {} ({} lines, {} bytes)",
        file_path,
        line_count,
        content.len()
    );

    std::fs::write(&file_path, &content).map_err(|e| {
        error!("Failed to write .env file to {}: {}", file_path, e);
        e.to_string()
    })?;

    info!("Auto-synced .env file to {}", file_path);
    Ok(())
}

/// Sanitize a string to be a valid environment variable name
/// - Convert to uppercase
/// - Replace invalid characters (dashes, dots, spaces) with underscores
/// - Remove any other non-alphanumeric characters except underscore
fn sanitize_env_var_name(name: &str) -> String {
    name.to_uppercase()
        .chars()
        .map(|c| {
            if c.is_ascii_alphanumeric() || c == '_' {
                c
            } else if c == '-' || c == '.' || c == ' ' {
                '_'
            } else {
                '\0' // Will be filtered out
            }
        })
        .filter(|&c| c != '\0')
        .collect()
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::db::create_db_table;
    use crate::migration::migrate_configs;
    use crate::models::config_state_model::ConfigState;
    use crate::utils::config::insert_config_with_pool;
    use crate::utils::config_state::update_config_state_with_pool;

    async fn setup_test_db() -> SqlitePool {
        let pool = SqlitePool::connect("sqlite::memory:")
            .await
            .expect("Failed to connect to in-memory database");
        create_db_table(&pool)
            .await
            .expect("Failed to create tables");
        migrate_configs(Some(&pool))
            .await
            .expect("Failed to run migrations");
        pool
    }

    #[test]
    fn test_sanitize_env_var_name() {
        assert_eq!(sanitize_env_var_name("postgres"), "POSTGRES");
        assert_eq!(sanitize_env_var_name("my-service"), "MY_SERVICE");
        assert_eq!(sanitize_env_var_name("my.service"), "MY_SERVICE");
        assert_eq!(sanitize_env_var_name("my service"), "MY_SERVICE");
        assert_eq!(sanitize_env_var_name("Service_Name"), "SERVICE_NAME");
        assert_eq!(sanitize_env_var_name("test@#$%name"), "TESTNAME");
    }

    #[test]
    fn test_derive_env_var_name_alias_priority() {
        let config = Config {
            alias: Some("my-alias".to_string()),
            service: Some("my-service".to_string()),
            target: Some("my-target".to_string()),
            ..Config::default()
        };
        assert_eq!(derive_env_var_name(&config), "MY_ALIAS");
    }

    #[test]
    fn test_derive_env_var_name_service_fallback() {
        let config = Config {
            alias: None,
            service: Some("my-service".to_string()),
            target: Some("my-target".to_string()),
            ..Config::default()
        };
        assert_eq!(derive_env_var_name(&config), "MY_SERVICE");
    }

    #[test]
    fn test_derive_env_var_name_target_fallback() {
        let config = Config {
            alias: None,
            service: None,
            target: Some("my-target".to_string()),
            ..Config::default()
        };
        assert_eq!(derive_env_var_name(&config), "MY_TARGET");
    }

    #[test]
    fn test_derive_env_var_name_empty_alias_fallback() {
        let config = Config {
            alias: Some("".to_string()),
            service: Some("my-service".to_string()),
            target: None,
            ..Config::default()
        };
        assert_eq!(derive_env_var_name(&config), "MY_SERVICE");
    }

    #[tokio::test]
    async fn test_generate_env_content_empty() {
        let pool = setup_test_db().await;
        let content = generate_env_content_with_pool(&pool, true).await.unwrap();

        assert!(content.contains("# Generated by kftray"));
        assert!(content.contains("# Updated:"));
    }

    #[tokio::test]
    async fn test_generate_env_content_with_running_config() {
        let pool = setup_test_db().await;

        // Insert a config
        let config = Config {
            alias: Some("postgres".to_string()),
            service: Some("postgres-service".to_string()),
            local_address: Some("127.0.0.1".to_string()),
            local_port: Some(5432),
            namespace: "default".to_string(),
            workload_type: Some("service".to_string()),
            protocol: "tcp".to_string(),
            ..Config::default()
        };

        insert_config_with_pool(config, &pool).await.unwrap();

        // Get the config ID
        let configs = crate::utils::config::read_configs_with_pool(&pool)
            .await
            .unwrap();
        let config_id = configs[0].id.unwrap();

        // Mark it as running
        let state = ConfigState {
            id: None,
            config_id,
            is_running: true,
            process_id: Some(1234),
        };
        update_config_state_with_pool(&state, &pool).await.unwrap();

        // Generate env content
        let content = generate_env_content_with_pool(&pool, true).await.unwrap();

        assert!(content.contains("POSTGRES_HOST=127.0.0.1"));
        assert!(content.contains("POSTGRES_PORT=5432"));
    }

    #[tokio::test]
    async fn test_generate_env_content_excludes_non_running() {
        let pool = setup_test_db().await;

        // Insert a config but don't mark it as running
        let config = Config {
            alias: Some("redis".to_string()),
            service: Some("redis-service".to_string()),
            local_address: Some("127.0.0.1".to_string()),
            local_port: Some(6379),
            namespace: "default".to_string(),
            workload_type: Some("service".to_string()),
            protocol: "tcp".to_string(),
            ..Config::default()
        };

        insert_config_with_pool(config, &pool).await.unwrap();

        // Generate env content with running_only=true
        let content = generate_env_content_with_pool(&pool, true).await.unwrap();

        // Should not contain redis entries since it's not running
        assert!(!content.contains("REDIS_HOST"));
        assert!(!content.contains("REDIS_PORT"));
    }

    #[tokio::test]
    async fn test_generate_env_content_includes_all_when_not_running_only() {
        let pool = setup_test_db().await;

        // Insert a config but don't mark it as running
        let config = Config {
            alias: Some("redis".to_string()),
            service: Some("redis-service".to_string()),
            local_address: Some("127.0.0.1".to_string()),
            local_port: Some(6379),
            namespace: "default".to_string(),
            workload_type: Some("service".to_string()),
            protocol: "tcp".to_string(),
            ..Config::default()
        };

        insert_config_with_pool(config, &pool).await.unwrap();

        // Generate env content with running_only=false
        let content = generate_env_content_with_pool(&pool, false).await.unwrap();

        // Should contain redis entries even though it's not running
        assert!(content.contains("REDIS_HOST=127.0.0.1"));
        assert!(content.contains("REDIS_PORT=6379"));
    }

    #[tokio::test]
    async fn test_generate_env_content_duplicate_names() {
        let pool = setup_test_db().await;

        // Insert two configs with the same alias but different namespaces
        let config1 = Config {
            alias: Some("postgres".to_string()),
            service: Some("postgres-service".to_string()),
            local_address: Some("127.0.0.1".to_string()),
            local_port: Some(5432),
            namespace: "production".to_string(),
            workload_type: Some("service".to_string()),
            protocol: "tcp".to_string(),
            ..Config::default()
        };

        let config2 = Config {
            alias: Some("postgres".to_string()),
            service: Some("postgres-service".to_string()),
            local_address: Some("127.0.0.1".to_string()),
            local_port: Some(5433),
            namespace: "staging".to_string(),
            workload_type: Some("service".to_string()),
            protocol: "tcp".to_string(),
            ..Config::default()
        };

        insert_config_with_pool(config1, &pool).await.unwrap();
        insert_config_with_pool(config2, &pool).await.unwrap();

        // Generate env content with running_only=false
        let content = generate_env_content_with_pool(&pool, false).await.unwrap();

        // Should contain namespaced entries to disambiguate
        assert!(content.contains("POSTGRES_PRODUCTION_HOST"));
        assert!(content.contains("POSTGRES_STAGING_HOST"));
    }
}
